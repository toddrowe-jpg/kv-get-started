import json
import datetime as dt
from dataclasses import dataclass
from pathlib import Path
import yaml

# ---------- Config models ----------
@dataclass
class BlogBrief:
    topic: str
    audience: str
    primary_keyword: str
    goal: str
    angle: str
    word_count: int
    sources: list[str]

def load_yaml(path: str) -> dict:
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)

def load_brief(path: str) -> BlogBrief:
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    return BlogBrief(**data)

# ---------- LLM wrapper (replace with your provider) ----------
def call_llm(messages: list[dict], model: str = "YOUR_MODEL") -> str:
    """
    Replace this with OpenAI/Anthropic/etc. call.
    Return the assistant text content.
    """
    raise NotImplementedError("Wire this to your LLM provider.")

# ---------- Prompt builders ----------
def system_prompt(style_guide: dict, brand_kit: dict) -> str:
    return f"""
You are a professional blog writing worker.

NON-NEGOTIABLE RULES:
- Follow the STYLE GUIDE and BRAND KIT exactly.
- Use active voice whenever possible.
- Use transitions to improve flow (per style guide).
- Maintain consistent brand tone and terminology.
- Avoid forbidden phrases.
- Output in Markdown.

STYLE GUIDE (authoritative):
{json.dumps(style_guide, indent=2)}

BRAND KIT (authoritative):
{json.dumps(brand_kit, indent=2)}
""".strip()

def outline_prompt(brief: BlogBrief) -> str:
    return f"""
Create a detailed blog outline for this brief.

BRIEF:
- Topic: {brief.topic}
- Audience: {brief.audience}
- Primary keyword: {brief.primary_keyword}
- Goal: {brief.goal}
- Angle: {brief.angle}
- Word count: ~{brief.word_count}
- Sources to reference: {brief.sources}

Return:
1) High CTR Title options (5)
2) One chosen title
3) Meta description (<= 155 chars)
4) Outline with H2/H3s and bullet notes under each
5) Suggested CTA
""".strip()

def draft_prompt(brief: BlogBrief, outline: str) -> str:
    return f"""
Write the full blog post based on the outline.

BRIEF:
- Topic: {brief.topic}
- Audience: {brief.audience}
- Primary keyword: {brief.primary_keyword}
- Goal: {brief.goal}
- Angle: {brief.angle}
- Target length: ~{brief.word_count} words

OUTLINE:
{outline}

Requirements:
- Use short paragraphs.
- Include transitions between major sections.
- Prefer active voice.
- Include a clear CTA near the end.
- Naturally include the primary keyword (no stuffing).
Return only the Markdown blog post.
""".strip()

def edit_prompt(draft_md: str) -> str:
    return f"""
Edit the draft to strictly comply with the STYLE GUIDE and BRAND KIT.

Do:
- Convert passive voice to active where feasible.
- Add transitions where the flow is choppy.
- Enforce brand phrasing and remove forbidden terms.
- Tighten sentences, remove fluff, keep it readable.
- Keep structure (headings) unless fixing clarity.

Return:
1) Final Markdown post only.
2) Then a short bullet list titled "Edits made" with 6-12 bullets.
""".strip()

# ---------- Worker ----------
def run_daily_blog_worker(
    brief_path="post_brief.json",
    style_path="style_guide.yaml",
    brand_path="brand_kit.yaml",
    out_dir="out",
):
    style_guide = load_yaml(style_path)
    brand_kit = load_yaml(brand_path)
    brief = load_brief(brief_path)

    sys = system_prompt(style_guide, brand_kit)

    # 1) Outline
    outline = call_llm([
        {"role": "system", "content": sys},
        {"role": "user", "content": outline_prompt(brief)}
    ])

    # 2) Draft
    draft = call_llm([
        {"role": "system", "content": sys},
        {"role": "user", "content": draft_prompt(brief, outline)}
    ])

    # 3) Edit/compliance pass
    edited = call_llm([
        {"role": "system", "content": sys},
        {"role": "user", "content": edit_prompt(draft)}
    ])

    # Save
    date_str = dt.date.today().isoformat()
    Path(out_dir).mkdir(parents=True, exist_ok=True)
    out_path = Path(out_dir) / f"blog_{date_str}.md"
    out_path.write_text(edited, encoding="utf-8")
    print(f"Saved: {out_path}")

if __name__ == "__main__":
    run_daily_blog_worker()

tone:
  traits: ["confident", "warm", "practical", "no hype"]
  reading_level: "grade_8_to_10"
voice:
  active_voice_target: 0.85   # 85%+ sentences should be active voice
  sentence_length_max_words: 22
  paragraph_length_max_lines: 4
transitions:
  requirement: "Add a transition every 2-3 paragraphs and between each H2 section."
  examples:
    - "Now let’s look at..."
    - "That said, there’s a catch..."
    - "With that in mind..."
formatting:
  h2_minimum: 4
  include_bullets: true
seo:
  include_keyword_in:
    - "title"
    - "first_150_words"
    - "one_h2"
cta:
  placement: "near_end"
  style: "helpful, not salesy"
banned_phrases:
  - "game-changer"
  - "revolutionary"

brand_name: "Bitxcapital"
positioning: "clear, trustworthy guidance for modern funding decisions"
preferred_terms:
  - "clients"     # not "customers"
  - "funding strategy"
forbidden_terms:
  - "guaranteed"
  - "risk-free"
taglines:
  - "Funding, made clear."
cta_templates:
  - "Want a clearer funding plan? Talk to the BITXcapital team."
style_notes:
  do:
    - "Use direct, helpful language."
    - "Be specific and concrete."
  dont:
    - "Overpromise outcomes."
    - "Use aggressive sales language."

brand_name: "BITX Capital"

brand_usage_rules:
  primary_name: "BITX Capital"
  lowercase_reference: "bitxcapital"
  domain: "bitxcapital.com"

  rules:
    - "Use 'BITX Capital' on first mention in every article."
    - "After first mention, you may use 'BITX Capital' or 'bitxcapital'."
    - "Use 'bitxcapital.com' only when referencing the website or CTA."
    - "Never write 'Bitx Capital' or 'BitX Capital'.

positioning: "Institutional-grade capital solutions delivered with clarity and discipline."

tone:
  traits:
    - "authoritative"
    - "confident"
    - "disciplined"
    - "strategic"
  avoid:
    - "hype"
    - "casual slang"
    - "aggressive sales language"

preferred_terms:
  - "capital solutions"
  - "structured capital"
  - "tailored financing"
  - "strategic capital deployment"
  - "institutional capital access"
  - "comprehensive capital stack"
  - "multi-product capital platform"
  - "financing structure"
  - "credit solution"
  - "capital facility"
  - "funding strategy"
  - "optimize capital structure"
  - "enhance liquidity strategy"
  - "unlock growth capital"
  - "scalable funding solutions"
  - "integrated financing options"
  - "diversified financing platform"
  - "structured lending portfolio"

forbidden_terms:
  - "guaranteed"
  - "risk-free"
  - "easy money"
  - "get rich"

taglines:
  - "Capital with discipline."
  - "Precision in capital strategy."

cta_templates:
  - "Explore your capital strategy at bitxcapital.com."
  - "Connect with BITX Capital to structure smarter funding."
  - "Start the conversation at bitxcapital.com."

style_notes:
  do:
    - "Lead with clarity."
    - "Use precise financial language."
    - "Support claims with reasoning."
  dont:
    - "Overpromise returns."
    - "Use emotional persuasion."
    - "Use exaggerated claims."

branding:
  enforce_first_mention_rule: true
  correct_common_mistakes:
    - "Bitx Capital"
    - "BitX Capital"
    - "BITX capital"
  require_domain_format: "bitxcapital.com"

Before finalizing:
- Confirm first mention uses "BITX Capital".
- Confirm no incorrect capitalization.
- Confirm website appears only as "bitxcapital.com".
- Remove any banned financial promises.

def build_blog_prompt(keyword: str, angle: str) -> str:
    return f"""
Write a blog targeting the long-tail keyword:
"{keyword}"

Blog format: {angle}

NON-NEGOTIABLE REQUIREMENTS:
- First mention must use "BITX Capital"
- Use bitxcapital.com only in the CTA
- Institutional tone, confident and disciplined
- Prefer active voice
- Add transitions between major sections
- 4–6 H2 sections
- Include a dedicated FAQ section near the end with EXACTLY 4 questions.
- Each FAQ must have:
  - a bold question line
  - a concise answer (2–4 sentences)
- The FAQs must be specific to the keyword and not generic.

OUTPUT FORMAT (Markdown):
- Use H2 for main sections.
- Include this exact header: "## FAQs"
- Under it, include exactly 4 Q&As in this format:

**Q1: ...?**  
A: ...

**Q2: ...?**  
A: ...

**Q3: ...?**  
A: ...

**Q4: ...?**  
A: ...

Length: 1,200–1,600 words.
Return Markdown only.
""".strip()

import re
import json
import time
from dataclasses import dataclass
from typing import List, Dict, Tuple
import requests
from bs4 import BeautifulSoup

# ----------------------------
# CONFIG
# ----------------------------

USER_AGENT = "BITXCapitalBlogWorker/1.0 (+https://bitxcapital.com)"
TIMEOUT = 20

# Block em dashes (—) and en dashes (–) just in case
DASH_FORBIDDEN = ["—", "–"]

# Simple in-text citation format: (Source 1) / (Source 2)
# with backlinks as markdown: [Source](https://...)
CITATION_PATTERN = re.compile(r"\(Source\s[12]\)")

@dataclass
class SourceDoc:
    url: str
    title: str
    text: str

# ----------------------------
# WEB SEARCH (plug your provider here)
# ----------------------------

def web_search_two_results(query: str) -> List[str]:
    """
    Return exactly 2 URLs relevant to the query.

    Implement this using your preferred search API:
    - SerpAPI
    - Bing Web Search API
    - Google Programmable Search Engine
    - Brave Search API

    For safety: restrict to reputable domains (gov, edu, major publishers, regulators, etc.)
    """
    raise NotImplementedError("Implement using a web search API and return 2 URLs.")

# ----------------------------
# FETCH + CLEAN HTML
# ----------------------------

def fetch_html(url: str) -> str:
    headers = {"User-Agent": USER_AGENT}
    r = requests.get(url, headers=headers, timeout=TIMEOUT)
    r.raise_for_status()
    return r.text

def extract_main_text(html: str) -> Tuple[str, str]:
    """
    Returns (title, cleaned_text).
    This is a lightweight extractor; upgrade to trafilatura/readability-lxml if you want.
    """
    soup = BeautifulSoup(html, "html.parser")

    title = (soup.title.get_text(strip=True) if soup.title else "").strip()

    # remove junk
    for tag in soup(["script", "style", "noscript", "svg", "footer", "header", "nav", "aside"]):
        tag.decompose()

    text = soup.get_text("\n", strip=True)
    # de-dupe blank lines
    lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
    cleaned = "\n".join(lines)

    # Truncate to reduce token load; tune as needed
    return title[:200], cleaned[:12000]

def load_sources(urls: List[str]) -> List[SourceDoc]:
    docs: List[SourceDoc] = []
    for url in urls:
        html = fetch_html(url)
        title, text = extract_main_text(html)
        if len(text) < 800:
            raise ValueError(f"Source too thin or blocked: {url}")
        docs.append(SourceDoc(url=url, title=title, text=text))
        time.sleep(0.5)  # be polite
    return docs

# ----------------------------
# LLM CALL (plug your provider here)
# ----------------------------

def call_llm(messages: List[Dict], model: str = "YOUR_MODEL") -> str:
    """
    Implement with your LLM provider.
    Must return assistant content as string.
    """
    raise NotImplementedError("Wire this to your LLM provider.")

# ----------------------------
# PROMPTS
# ----------------------------

def build_strict_writer_messages(
    keyword: str,
    angle: str,
    sources: List[SourceDoc],
) -> List[Dict]:
    s1, s2 = sources[0], sources[1]

    system = f"""
You are a blog writing worker for BITX Capital.

HARD RULES (NO EXCEPTIONS):
- Use active voice.
- No em dashes (—) and no en dashes (–). Use commas or parentheses instead.
- You MUST back up key claims using ONLY the two provided sources.
- Do NOT add facts not present in the sources. If a fact is not in the sources, omit it.
- Every section with factual claims must include an inline backlink to the supporting source.
- Use exactly these sources and no others:
  - Source 1 URL: {s1.url}
  - Source 2 URL: {s2.url}

CITATION STYLE:
- When you use a fact from Source 1, add: (Source 1) and include a markdown backlink near the claim: [{s1.title or "Source 1"}]({s1.url})
- When you use a fact from Source 2, add: (Source 2) and include a markdown backlink near the claim: [{s2.title or "Source 2"}]({s2.url})

OUTPUT:
- Markdown blog post.
- 4 to 6 H2 sections.
- Include "## FAQs" with EXACTLY 4 Q&As at the end.
- CTA near the end referencing bitxcapital.com (domain only as website mention).

If you are unsure, say it is not covered by the sources and remove it.
""".strip()

    user = f"""
Target long-tail keyword: "{keyword}"
Format/angle: {angle}
Length: 1,200 to 1,600 words

SOURCE 1 (use as evidence):
Title: {s1.title}
URL: {s1.url}
CONTENT:
\"\"\"{s1.text}\"\"\"

SOURCE 2 (use as evidence):
Title: {s2.title}
URL: {s2.url}
CONTENT:
\"\"\"{s2.text}\"\"\"

Write the blog now. Remember: no em dashes, and add inline backlinks to the source near the supported claim.
""".strip()

    return [{"role": "system", "content": system}, {"role": "user", "content": user}]

# ----------------------------
# VALIDATORS
# ----------------------------

def validate_no_dashes(md: str) -> None:
    for ch in DASH_FORBIDDEN:
        if ch in md:
            raise ValueError("Found forbidden dash character (— or –).")

def validate_two_sources_only(md: str, sources: List[SourceDoc]) -> None:
    urls = [re.escape(s.url) for s in sources]
    # ensure both are present as backlinks
    for s in sources:
        if s.url not in md:
            raise ValueError(f"Missing backlink to required source: {s.url}")

    # crude guard: disallow other http(s) links besides the two sources and bitxcapital.com
    # (allow bitxcapital.com)
    allowed = set([sources[0].url, sources[1].url, "https://bitxcapital.com", "http://bitxcapital.com"])
    found = set(re.findall(r"https?://[^\s)>\"]+", md))
    extras = {u for u in found if u not in allowed}
    if extras:
        raise ValueError(f"Found disallowed external links: {sorted(extras)[:5]}")

def validate_faqs(md: str) -> None:
    if "## FAQs" not in md:
        raise ValueError("Missing '## FAQs' section.")
    # must include exactly Q1..Q4 lines
    q_matches = re.findall(r"^\*\*Q([1-4]):.*\?\*\*\s*$", md, flags=re.MULTILINE)
    if len(q_matches) != 4:
        raise ValueError(f"Expected exactly 4 FAQ questions (Q1–Q4). Found {len(q_matches)}.")

def validate_has_citations(md: str) -> None:
    # Require at least some citations
    cites = CITATION_PATTERN.findall(md)
    if len(cites) < 6:
        raise ValueError("Too few citations. Add more supported claims with (Source 1)/(Source 2).")

def validate_all(md: str, sources: List[SourceDoc]) -> None:
    validate_no_dashes(md)
    validate_faqs(md)
    validate_has_citations(md)
    validate_two_sources_only(md, sources)

# ----------------------------
# MAIN WORKFLOW
# ----------------------------

def generate_blog_with_two_sources(keyword: str, angle: str) -> str:
    urls = web_search_two_results(keyword)
    if len(urls) != 2:
        raise ValueError("Search must return exactly 2 URLs.")
    sources = load_sources(urls)

    messages = build_strict_writer_messages(keyword, angle, sources)
    draft = call_llm(messages)

    # Validate. If fails, run one repair pass.
    try:
        validate_all(draft, sources)
        return draft
    except Exception as e:
        repair_prompt = f"""
Fix the blog to pass validation:

Errors: {str(e)}

Rules:
- Keep meaning and structure.
- Add missing inline backlinks to the correct source.
- Remove any unsupported factual claims.
- Remove any external links not in the two sources or bitxcapital.com.
- Remove any em/en dashes.
- Ensure at least 6 citations using (Source 1) and/or (Source 2).
- Keep exactly 4 FAQs labeled Q1..Q4.

Return Markdown only.
BLOG:
{draft}
""".strip()

        repaired = call_llm([
            {"role": "system", "content": messages[0]["content"]},
            {"role": "user", "content": repair_prompt}
        ])
        validate_all(repaired, sources)
        return repaired

import re
from typing import List, Dict

# ----------------------------
# LLM call placeholder
# ----------------------------
def call_llm(messages: List[Dict], model: str = "YOUR_MODEL") -> str:
    """
    Wire this to your LLM provider (OpenAI/Anthropic/etc).
    Must return assistant text.
    """
    raise NotImplementedError("Implement call_llm().")

# ----------------------------
# Summary prompt + injection
# ----------------------------

FORBIDDEN_DASHES = ["—", "–"]

def build_summary_messages(keyword: str, blog_md: str) -> List[Dict]:
    system = """
You are an expert editor writing a top-of-post summary for a blog.

Hard rules:
- Write 4 to 5 sentences total.
- High CTR: make it punchy and benefit-led, but not hypey.
- Match an institutional tone for BITX Capital.
- No em dashes (—) and no en dashes (–).
- No new facts. Only summarize what is already in the blog.
- Avoid clickbait. Be specific.

Output exactly this format (Markdown), nothing else:

> <sentence 1> <sentence 2> <sentence 3> <sentence 4> [<sentence 5 if needed>]
""".strip()

    user = f"""
Target keyword: "{keyword}"

BLOG (Markdown):
{blog_md}

Write the summary now.
""".strip()

    return [{"role": "system", "content": system}, {"role": "user", "content": user}]

def validate_summary(summary_block: str) -> None:
    # must start with blockquote
    if not summary_block.strip().startswith(">"):
        raise ValueError("Summary must be a single Markdown blockquote starting with '>'.")

    # block em/en dashes
    for ch in FORBIDDEN_DASHES:
        if ch in summary_block:
            raise ValueError("Summary contains a forbidden dash character (— or –).")

    # count sentences (simple heuristic)
    text = summary_block.lstrip(">").strip()
    # split on ., !, ?
    sentences = [s.strip() for s in re.split(r"[.!?]+", text) if s.strip()]
    if not (4 <= len(sentences) <= 5):
        raise ValueError(f"Summary must be 4–5 sentences. Found {len(sentences)}.")

def inject_summary_at_top(blog_md: str, summary_block: str) -> str:
    """
    Inserts the summary after the H1 title if present; otherwise at the very top.
    """
    lines = blog_md.splitlines()
    if lines and lines[0].startswith("# "):
        # Insert after title + blank line
        out = [lines[0], "", summary_block.strip(), ""]
        out.extend(lines[1:])
        return "\n".join(out).strip() + "\n"
    else:
        return (summary_block.strip() + "\n\n" + blog_md.strip() + "\n")

def add_top_summary(keyword: str, blog_md: str, model: str = "YOUR_MODEL") -> str:
    """
    Generates a 4–5 sentence high-CTR summary and injects it at the top of the blog.
    Retries once with a repair prompt if validation fails.
    """
    messages = build_summary_messages(keyword, blog_md)
    summary = call_llm(messages, model=model).strip()

    try:
        validate_summary(summary)
    except Exception as e:
        repair = f"""
Fix the summary to pass validation.

Error: {str(e)}

Rules:
- 4 to 5 sentences total
- One Markdown blockquote starting with '>'
- No em/en dashes
- No new facts
Return only the corrected summary blockquote.
SUMMARY:
{summary}
""".strip()
        summary = call_llm([messages[0], {"role": "user", "content": repair}], model=model).strip()
        validate_summary(summary)

    return inject_summary_at_top(blog_md, summary)

# ----------------------------
# Example usage inside your worker:
# ----------------------------
# blog_md = generate_blog_with_two_sources(keyword, angle)  # your existing function
# blog_md = add_top_summary(keyword, blog_md)
# save blog_md to file / CMS

import re
from typing import List, Dict, Optional

FORBIDDEN_DASHES = ["—", "–"]

def call_llm(messages: List[Dict], model: str = "YOUR_MODEL") -> str:
    """Wire this to your LLM provider. Must return assistant text."""
    raise NotImplementedError("Implement call_llm().")

# ----------------------------
# Build an HTML comparison table (LLM-generated)
# ----------------------------

def build_table_messages(keyword: str, blog_md: str) -> List[Dict]:
    system = """
You create a single HTML comparison table to embed inside a Markdown blog post.

Hard rules:
- Output ONLY valid HTML (no Markdown, no backticks).
- Produce exactly ONE <table> element (no surrounding <html> or <body>).
- No em dashes (—) and no en dashes (–).
- No new facts. Use only information already present in the blog.
- Keep it broadly useful: a comparison chart relevant to the keyword.
- 4 to 7 rows, 3 to 5 columns.
- Use <thead>, <tbody>, <th>, <tr>, <td>.
- Keep cell text concise (max ~12 words per cell).
- Do not include external links.

If the blog lacks enough detail to compare, create a generic decision table that summarizes options
mentioned in the blog without adding new facts.
""".strip()

    user = f"""
Target keyword: "{keyword}"

BLOG (Markdown):
{blog_md}

Create the HTML table now.
""".strip()

    return [{"role": "system", "content": system}, {"role": "user", "content": user}]

def validate_html_table(table_html: str) -> None:
    if any(ch in table_html for ch in FORBIDDEN_DASHES):
        raise ValueError("Table contains a forbidden dash character (— or –).")

    stripped = table_html.strip()
    if "```" in stripped:
        raise ValueError("Table must be raw HTML only (no code fences).")

    # Must contain exactly one table element
    open_tables = len(re.findall(r"<table\b", stripped, flags=re.IGNORECASE))
    close_tables = len(re.findall(r"</table>", stripped, flags=re.IGNORECASE))
    if open_tables != 1 or close_tables != 1:
        raise ValueError("Output must contain exactly one <table>...</table>.")

    # Basic structure checks
    required_tags = ["<thead", "<tbody", "<tr", "<th", "<td"]
    for tag in required_tags:
        if re.search(tag, stripped, flags=re.IGNORECASE) is None:
            raise ValueError(f"Missing required HTML tag: {tag}")

def insert_table_into_blog(blog_md: str, table_html: str, after_heading: Optional[str] = None) -> str:
    """
    Inserts the table after a chosen H2 heading if provided and found; otherwise inserts after the first H2.
    Falls back to inserting after the title (H1) or at top if no headings exist.
    """
    lines = blog_md.splitlines()

    def find_h2_index(match_text: Optional[str]) -> Optional[int]:
        if not match_text:
            return None
        pattern = re.compile(rf"^##\s+{re.escape(match_text)}\s*$", re.IGNORECASE)
        for i, ln in enumerate(lines):
            if pattern.match(ln.strip()):
                return i
        return None

    # Prefer inserting after a specific H2 if you pass one (e.g., "Comparison", "Options", etc.)
    idx = find_h2_index(after_heading)

    # Otherwise after the first H2
    if idx is None:
        for i, ln in enumerate(lines):
            if ln.startswith("## "):
                idx = i
                break

    insert_block = ["", "<!-- Comparison Table -->", table_html.strip(), ""]

    # If we found an H2, insert after its heading line + one blank line
    if idx is not None:
        out = lines[: idx + 1] + insert_block + lines[idx + 1 :]
        return "\n".join(out).strip() + "\n"

    # Else, if there's an H1 at top, insert after it
    if lines and lines[0].startswith("# "):
        out = [lines[0]] + insert_block + lines[1:]
        return "\n".join(out).strip() + "\n"

    # Else insert at top
    return ("\n".join(insert_block).strip() + "\n\n" + blog_md.strip() + "\n")

def add_html_comparison_table(keyword: str, blog_md: str, model: str = "YOUR_MODEL", after_heading: Optional[str] = None) -> str:
    """
    Generates and inserts an HTML comparison table into the blog.
    Retries once with a repair prompt if validation fails.
    """
    messages = build_table_messages(keyword, blog_md)
    table_html = call_llm(messages, model=model).strip()

    try:
        validate_html_table(table_html)
    except Exception as e:
        repair = f"""
Fix the HTML so it passes validation.

Error: {str(e)}

Rules:
- Output ONLY a single valid <table>...</table> element
- Include <thead> and <tbody>
- No em/en dashes
- No new facts beyond the blog
- 4 to 7 rows, 3 to 5 columns
Return ONLY the corrected HTML table.
BAD HTML:
{table_html}
""".strip()
        table_html = call_llm([messages[0], {"role": "user", "content": repair}], model=model).strip()
        validate_html_table(table_html)

    return insert_table_into_blog(blog_md, table_html, after_heading=after_heading)

# ----------------------------
# Example usage in your pipeline:
# ----------------------------
# blog_md = generate_blog_with_two_sources(keyword, angle)
# blog_md = add_top_summary(keyword, blog_md)        # from your earlier step
# blog_md = add_html_comparison_table(keyword, blog_md, after_heading="How to choose")
# save blog_md

